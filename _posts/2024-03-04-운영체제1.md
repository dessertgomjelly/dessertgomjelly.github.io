---
layout: single
title: "[운영체제] 1.introduction" 
categories: Operating_Systems
tag: [Operating_Systems]
use_math: true #수학 공식 가능하게
sidebar:
    nav: "counts"
---

<style>
  body {
    font-size: 15px; /* 폰트 사이즈 조절 */
  }
</style>





**[참고자료]** **[Operating System Concepts 에센셜]** 저자(글) · Abraham Silberschatz, Peter Baer Galvin ,  Greg Gagne 번역 조유근, 박민규 , 고건
{: .notice--danger}





# Chapter 1: Introduction

<br>

<br>

## Contents

-  운영체제는 어떤 SW인지
-  Computer System의 구조
-  Multiprogram 기법
-  프로세스
-  메모리
-  보관장치
-  보호
-  컴퓨팅 환경
-  오픈 소스 OS

<br>

<br>

## 1.1 What Operating Systems Do

-  운영체제는 어떤일을 할까?
-  관점에 따라 다르다( 사용자, computer)
-  PC의 경우 개인용이여서 자원 사용의 효율성이 상관 없다.
-  하지만 mainframe, minicomputer처럼 여러 사람이 사용하면 효율적 관리가 필요하다.
-  [wokrstaiton] 네트워크를 통해 서버 연결 해야하는 시스템은 전용 리소스와 서버 공유 리소스의 조화가 중요하다.
-  smartphone, PC는 독립적인 장치이며 제한된 성능(배터리로 동작)한다.
-  [임베디드 컴퓨터] 장치 및 자동차에 내장된 컴퓨터는 사용자 인터페이스가 필요없다.

<br>

<br>

## 사용자 관점

-  PC, Notebook은 모든 기능을 개인이 사용한다.
   -  PC에 장착된 하드웨어를 효욜적으로 사용하는 것은 중요하지 않음 → 단지 편의성만 중요.
-  사용자 관점에서 OS는 편의성만이 중요하다.
   -  **자원의 효율적 사용은 중요 하지 않음**

<br>

<br>

## What Operating System Do(Cont’d)

-  OS is a resource(하드웨어 cpu.) allocator
   -  **운영체제는 자원할당기이다.**
   -  제한된 자원을 최대한 효율적으로 사용해야 하며 공평하게 분배 되어야 한다.
      -  자원은(CPU, Memory, I/O) 이며, OS는 HW와 밀접한 관계이다.
-  OS is a control program.
   -  운영체제는 제어 프로그램이다.
   -  운영체제는 응용소프트웨어를 사용하기 위해 필요.
      -  사용자 Interface 제공, 오류 제어, 입출력 연산에 관여
   -  CPU, 메모리 등의 자원을 언제 어떻게 사용 할지를 결정하는것이 운영체제이다.
      -  하나의 자원을 가지고 스케쥴링(자원할당) 을 하기위한 순서 등을 결정한다.

<br>

<br>

## Operating System Definition(운영 체제 정의)

-  다양한 응용프로그램이 필요로 하는 입출력 연산, 자원 제어 할당의 공통기능을 하나의 SW로 만든것이다.
-  보편적으로 인정되는 정의가 없다.
-  OS 설치 직후 컴퓨터 SYSTEM에 담겨지는 모든것? … 그럼 메모장도 운영체제야? …. 이건 쫌 애매하다.
-  운영체제는 컴퓨터가 동작하는 한 항상 실행중이다  =  운영체제는 항상 메모리에 상주하고 있다.
   -  [Kernel] 항상 실행중이기 때문에 운영체제를 커널이라고 부른다.
   -  [System program] 운영체제의 일부이긴 하지만 커널에 포함될 필요없는 프로그램이다.
-  컴퓨터 사용자와 컴퓨터 하드웨어 간의 중개 역할을 하는 프로그램 → 이 수업의 가장 중요한 챕터 ‘효율성’
   -  효율적 메모리 사용.
-  효율성, 편리성을 위해 사용.

```
운영체제는 컴퓨터 사용자와 HW 사이에서 중간 역할을 한다.
역할이란 사용자 프로그램 실행, HW 효율적 사용 등
```

<br>

<br>

## Computer System Structure

<img src="{{site.url}}/images/os1/os0.png" style="zoom:60%;" />

계층적 구조이다.

-  하드웨어
   -  자원을 뜻한다.
   -  CPU, Memory, I/O device, other computers(server 의 경우 컴퓨터 자체가 자원이다.)
   -  모든 프로그램은 실행되려면 메모리에 로딩 되어야한다. → CPU가 실제 실행을 담당한다.
   -  CPU 관점에서 보면 매번 메모리에 로드되어있는 CPU명령을 실행한다.
   -  프로그램 실행이란 CPU가 항상 메모리에 접근하는 것을 의미한다.
-  운영체제(= System SW)
   -  하드웨어와 응용프로그램의 사용을 제어, 조율하는 일을 한다.
-  Sytem and application programs
   -  응용프로그램과 시스템 프로그램
      -  [System program] 커널은 아니지만 컴퓨터 시스템의 동작 제어 관리 프로그램을 의미 ex) 유틸리티, 셸, 파일 시스템, 인터프리터
-  User
   -  사람, machine, other computers(서버의 경우)

<br>

<br>

## Computer System Organizaion(=HW)

<img src="{{site.url}}/images/os1/os1.png" style="zoom:60%;" />

-  CPU(명령 실행장치)
   -  메모리에 로드되어있는 CPU명령을 실행하기 위해 항상 메모리에 접근한다.
-  Memory(프로그램 실행동안에 저장되는 위치)
-  divice controller를 포함한 I/O 장치
   -  `Divice driver는 운영체제 커널에서 동작.`
-  HW는 버스(데이터통로)를 통해 동작한다.
   -  하나 이상의 CPU, 장치 컨트롤러가 공통 버스를 통해 연결되어 공유 메모리에 액세스 제공
   -  CPU와 장치의 동시 실행(접근)이 메모리 사이클 경쟁을 겪음 = 메모리는 한번에 하나의 장치만 접근할 수 있다.

<br>

<br>

## Computer System Operation

컴퓨터 시스템 작동

-  입출력(I/O) 장치와 CPU는 동시에 실행될 수 있음
   -  독립적으로 각자의 기능을 수행.
-  I/O 각 장치 컨트롤러는 특정 장치 유형을 담당하며, 각 장치 컨트롤러에는 로컬 버퍼가 있음
   -  메모리와 장치 컨트롤러 버퍼 와의 상호작용
   -  버퍼 = 컨트롤러에서 메모리 역할을함
   -  Input device : 입력데이터(로컬버퍼) → 메인 메모리 로드
   -  Output device : 메인 메모리 → 출력데이터(로컬 버퍼)
-  CPU는 데이터를 주고받기 위해 메인 메모리와 CPU 레지스터 간에 데이터를 이동
   -  메모리와 CPU의 레지스터와의 상호작용
-  장치 컨트롤러는 작업이 완료되었음을 CPU에 알리기 위해 인터럽트를 발생시킴
   -  인터럽트 = 장치가 CPU에 보내는 전기적신호
      -  인터럽트의 출발점은 장치, 도착점은 CPU

I/O 장치는 자신의 동작 완료(컨트롤러의 로컬 버퍼→ 메인메모리, 메인메모리→로컬 버퍼) 를 알리기 위해 전기적 신호인 인터럽트를 발생시킨다.

<br>

<br>

## Common Functions of Interrupts

-  [Interrupt vector] 자료구조 이며, Interrupt의 고유 숫자인 ISR(시작 주소) 가 저장되어있다.
   -  CPU는 동작하는 도중 인터럽트 신호를 받으면 즉시 하던 일을 멈추고 처리를 위해 Interrupt vector를 통해 ISR을 실행시킨다.
   -  CPU마다 Interrupt Vector는 미리 정해져 있다.
-  [Interrupt Service Routine]
   -  프로그램 실행 제어가 OS의 커널모드로 넘어갔다는 의미이다. CPU는 인터럽트 실행전의 작업 주소를 ISR시작 직전에 저장한다.
      -  CPU는 PCB에 PC(실행중인 프로그램의 주소)를 포함한 레지스터 값을 스택 영역에 저장한다.
-  [Trap, exception]
   -  CPU 자체 동작원인 Interrupt이다.
   -  CPU 명령 실행 과정 중에 발생한 경우이다.
   -  내부 인터럽트, SW 인터럽트라고 불리며 처리과정은 외부 인터럽트와 비슷하다.

<br>

<br>



## 인터럽트(CPU입장에서 하나의 인터럽트가 왔을 때 동작을 어떻게 할까?)

1. CPU는 인터럽트가 오는 순간에 즉시 하던 일을 멈춤.
2. CPU가 자신의 형태를 저장.
   -  상태 저장이란 CPU가 자신의 상태를  사용중인 레지스터(PC 레지스터,  현재 실행 중인 명령어의 주소를 담고있음) 를 메모리에 저장하는 것을 의미.
   -  예를 들어, 10개의 인터럽트를 사용하면 그 것을 메모리에 저장
3. 미리 정해진 Interrupt Service Routine(ISR) 으로 분기.
   -  = Interrupt Handling function
      -  이 함수가 실행된 다는 것은 인터럽트가 처리 된다는 것을 의미한다.
4. 2단계에서 한 상태를 복원한다.
5. 재시작.

응용프로그램의 인터럽트 발생 원인은 다양하다.

인터럽트 발생 → ISR, 인터럽트 처리함수 실행 후 리턴 →

파란색은 응용프로그램의 실행, 빨간색은 커널의 실행을 의미한다.

<img src="{{site.url}}/images/os1/os2.png" style="zoom:60%;" />

<br>

<br>

## Interrupt Handling(컴퓨터 시스템에서 발생하는 인터럽트를 감지하고, 해당 인터럽트를 적절하게 처리하는 과정)

Interrupt 발생 → CPU는 즉시 하던일 멈춤 → CPU는 자신의 레지스터 값 저장(현재 프로그램 실행 주소값, pc를 포함한 모든 레지스터값) → Interrupt vector를 통해 ISR실행. → 상태 복원 → 재시작

-  [Pooling]
   -  과거 기법이며, 어느 I/O인지 각 장치마다 인터럽트 발생 여부를 확인
   -  인터럽트를 받지만 누가 보냈는지 알 수 없음. → 장치마다 물어봐야함.
-  [Interrupt vector]
   -  인터럽트 고유 번호와 그에 해당하는 특정 ISR의 시작 주소값을 가지고 있음.
   -  운영체제의 자료구조라고 할 수 있음.
   -  0~255 8bit로 구성. 256개가 정의 되어있어야함.
   -  1번은 키보드 신호! ISR 01 번 주소로 가!

| 0    | ISR 00 |
| ---- | ------ |
| 1    | ISR 01 |
| 2    |        |

<br>

<br>

## Interrupt Timeline

(1) [입출력 개시 요청] : 응용프로그램이 I/O 명령 실행, I/O는 CPU로부터 입출력 시작 지시를 받음 (idle → transferring)

(2) [입출력 실행]

-  CPU: 응용프로그램을 여전히 실행,
-  I/O : 입출력 시작 이후 동작 수행(장치 컨트롤러의 로컬 버퍼 ↔ 메모리 상호작용)

(3) [Interrupt 발생] :  ISR 실행(vector 방식), CPU가 모든 장치 한바퀴 돌기(Pooling 방식)

-  CPU: 자신의 레지스터 pcb에 저장 후 ISR에게 제어권을 넘겨(제어권을 넘긴다는건 커널모드의 집입을 의미, CPU의 실행권한확장) ISR실행

<img src="{{site.url}}/images/os1/os3.png" style="zoom:60%;" />

CPU

-  보통의 경우 응용프로그램 실행
-  (4)와 같은 모습은 커널의 실행

(1) 응용 프로그램이 I/O 에 대해 지시.

-  I/O에 대한 입출력 함수 실행.

(2) I/O 에서는 입출력에 대한 동작, CPU는 입출력 지시 후 자기 할일을 이어간다.

-  CPU는 (1) 기준, 앞뒤로 다른 프로그램 실행
-  파란줄로 쭉 표시 이유?
   -  입출력 지시 이후에도 응용프로그램을 실행하고 있기때문에

Transfor done

(3) 장치가 CPU에게 인터럽트 발생

-  장치 : I/O 상태로
-  CPU : 인터럽트 동작 순서대로 발생, 즉 (4)은 인터럽트 처리 함수 실행을 의미.

(4) 이후에는 CPU 가 어떤 응용프로그램으로 돌아갈까?

-  이전의 응용프로그램이 B라면, (4) 이후로 B로 돌아가지 않는다.
-  즉 인터럽트 발생 시점의 이전 프로세스로 돌아가지 않는다.

<br>

<br>

## Storage Structure

-  메인 메모리
   -  Dynamic RAM & DRAM
   -  CPU가 유일하게 직접 접근 할 수있는 장치이다.
   -  Random access
      -  어떤 장치든 저장 위치 에 관계없이 속도가 일정한 것을 의미한다.
      -  그에 비해 하드디스크는 저장되는 위치에 따라 접근 속도가 다른다.
   -  휘발성
-  Secondary storage
   -  반 휘발성(데이터를 전원이 꺼져도 보존)
-  Magnetic disks(하드 디스크)
   -  512바이트의 sector 단위로 저장됨.
   -  tracks기반 저장 방법.
   -  디스크 컨트롤러는 장치와 컴퓨터 간의 논리적 상호 작용을 결정
-  SSD
   -  플래시메모리를 촘촘히 쌓음
   -  표준적인 구조가 있는것이 아니라 플래시 메모리 쌓는 구조에 따라 성능 차이가 남.
   -  보조 기억 장치로서 하드디스크를 대체해 가고 있음.

<br>

<br>

## Storage Hierarchy

데이터 접근속도, 단위 용량당 가격, 휘발성에 따라 등급을 매김.

<img src="{{site.url}}/images/os1/os4.png" style="zoom:60%;" />

Register

-  CPU안의 registers 즉 메모리를 의미.

Caching

-  CPU내부, 바로 옆에 있으며 최근 명령,데이터 복사본을 갖고 있음.(임시저장 장치)

Main memory

========================비휘발성=====================

Device Driver

-  SSD 이하의 저장장치는 I/O에 해당한다, 따라서 Device Drivcer를 통해 접근

<br>

<br>

## Caching

-  빠른 데이터 접근을 위해 캐싱을 사용한다.
   -  느린 장치 정보를 빠른 정보에 복사
   -  CPU의 데이터 빠른 접근을 위해
-  캐시는 작다. 따라서 새로운 데이터가 오면 교체된다.
   -  교체 정책에 따라서 Cache replacement 한다.

<br>

<br>

## I/O Structure

입출력 방식은 2가지(CPU와 I/O의 속도가 다르기 때문이다)

-  Synchronous I/O (동기적 입출력)
   -  I/O 시작 후 I/O 끝난 후에만 프로그램 실행이 이어진다.
   -  프로그램은 입출력 요청후 IDlE상태에서 기다린다.
-  Asynchronous I/O (비동기적 입출력)
   -  동시에 여러 I/O가 가능하다.
   -  Device-status-table을 유지하며 입출력의 현재 상태 관리한다.

<br>

<br>

## Direct Memory Access Structure

-  Programmed I/O
   -  입출력에 필요한 전후과정에 CPU가 개입.
   -  (저속장치)
-  DMA (Direct memory Access)
   -  CPU개입 없이 device controller, main memory간의 블록 단위 데이터 전송 방법이다.
   -  고속장치(하드디스크) 입출력의 시작만 CPU가 지시, 출력은 해당장치의 controller 가 직접 접근해서 메모리로부터 데이터 가져와서 저장.

<br>

<br>

## 폰노이만 아키텍쳐

<img src="{{site.url}}/images/os1/os5.png" style="zoom:60%;" />

(1) data movement, instruction execiton cycle

-  CPU는 끊임없이 메모리를 접근한다.
-  프로그램 실행을 위해 명령어를 가져와야하기 때문.
-  Bus를 거쳐서 CPU로 이동.
-  성능을 높이기위해 cache(저속장치에서의 데이터, 최근 명령을 임시 저장)

입출력 명령인 경우에는 Cpu가 Device에게 접근한다.

-  (2) programmed
-  (3) DMA
   -  데이터 주고 받는것은 CPU가 아니라 장치가 직접 메모리에 접근한다.

<br>

<br>

## 1.3 Computer System Architecture

-  대부분의 시스템은 단일 범용 프로세서를 사용
-  다중프로세서 시스템의 중요성 증가
-  병렬 시스템 또는 다중 코어 시스템으로도 알려져 있음

**`다중프로세서 시스템의 장점`**

1. `처리량 증가`
2. `규모의 경제`
3. `신뢰성 증대 - 한 CPU가 망가져도됨.`

**다중프로세서 시스템의 두 종류**

1. 비대칭 다중 처리 (Asymmetric Multiprocessing)
2. 대칭 다중 처리 (Symmetric Multiprocessing)

**비대칭 다중 처리 (Asymmetric Multiprocessing)**

-  프로세서 간에 작업 부하가 분산되지 않는 경우 사용
-  하나의 프로세서가 주요 작업을 담당하고, 다른 프로세서는 보조적인 작업을 수행

**대칭 다중 처리 (Symmetric Multiprocessing) SMP!!!!!!!**

-  여러 프로세서가 공통된 메모리에 접근하여 작업을 수행
-  프로세서 간의 작업 부하가 균형있게 분산됨
-  두 가지 주요 변형: UMA와 NUMA

**UMA (Uniform Memory Access)**

-  모든 프로세서가 메모리에 동일한 접근. 시간을 가짐

**NUMA (Non-Uniform Memory Access)**

-  각 프로세서가 메모리에 접근하는 시간이 다를 수 있음

오늘날의 다중처리 시스템은 SMP(Symmetric Multiprocessing) 가 국룰이다.

버스 형태이다.

<img src="{{site.url}}/images/os1/os6.png" style="zoom:60%;" />

<br>

<br>

## A Dual-Core Design

<img src="{{site.url}}/images/os1/os7.png" style="zoom:60%;" />

-  Multi-chip and multicore
-  레지스터와 캐쉬를 독자적으로 갖는다. 칩 내부 통신이 빠르다.
-  사실 버스를 통한 통신은 비효율적이다. 따라서 멀티코어는 버스가 형태가 아니라 직접 통신하기때문에 효율적이다.

VS blade server

-  블레이드 서버와 멀티 코어의 차이점은 각 보드가 독립적 OS를 갖는다.

<br>

<br>

## Clustered Systems

-  둘 이상의 독자적 computer System이 비교적 고속의 network로 묶여 마치 단일 컴퓨터 system처럼 동작한다.(같이 일하는 복수 system)
-  고속의 interconnect 를 이용하여 통신하는 다중처리 시스템.
   -  interconnect는 lan보다 빠르다.
-  공통의 하드디스크를 사용한다. san (storage-area network)이라 한다.
-  고 가용성 서비스 (24시간 내내 돌아가야하는 컴퓨터), (고장이 나도 계속 돌아가야하는 시스템)
   -  다음 그림의 각 노드를 1,2,3이라 했을 때 1 노드가 고장 날때는 2노드가 그 일을 하고, 1은 수리한다.
   -  한 노드만 서비스를 하고 나머지 노드는 대기한다.
      -  동작을 계속 이어나갈 수 있게 한다.
-  high-performance computing (HPC)
   -  고성능 컴퓨팅을 위한 클러스터 시스템에서 병렬 처리를 통해 작업을 분산하여 처리하는 것이 중요하다

<img src="{{site.url}}/images/os1/os8.png" style="zoom:60%;" />

<br>

<br>

## 1.4 Operating System Structure (굉장히 중요)

많은 운영체제들이 멀티 프로그래밍을 한다.

-  운영체제는 한번의 여러개의 잡(실행해야하는 응용프로그램)을 메모리에 적재한다.
-  운영체제는 잡 중에 한개를 실행
   -  언젠가는 입출력을 요청하고 입출력 완료하기를 기다리는 상태가 된다.
   -  기다려야한다면 다른잡을 실행한다.
   -  다음 잡을 고르는 행위를 잡 스케쥴링이라고 한다.
-  잡은 배치시스템  일 때

메인 메모리 모습은 다음과 같다.

<img src="{{site.url}}/images/os1/os9.png" style="zoom:60%;" />

JOB 1 을 예로 들어보면

<img src="{{site.url}}/images/os1/os10.png" style="zoom:60%;" />

모든 시스템은 (cpu 사용, 입출력) 의 반복 형태이다.

빨간 색 부분에서 CPU가 중단 될 때 CPU를 JOB 2에게 양도하게 된다.

MUlti programming 방식

-  JOB이 여러개 있을 때 CPU 사용이 중단 된 시점에서 다음 JOB에게 양도한다.
   -  CPU를 쉬지 않게 하는 것이 중요 포인트 !
   -  CPU의 효율적 사용을 위해
-  다음번 CPU가 사용 JOB을 선택하는것이 JOB 스케쥴링이다.

<img src="{{site.url}}/images/os1/os11.png" style="zoom:60%;" />

<br>

<br>

## TimeSharing (= multitasking)

-  멀티 프로그램의 확장버전. 다른 점은 동시 실행 프로그램의 개수가 엄청나게 많다.
-  CPU를 짧게 사용하고 입출력을 빈번하게 사용한다.
   -  수백개의 프로그램이 계쏙 돌아간다. → 엄청나게 빠르다.
-  Response time 은 1초 이내이다.
-  CPU 스케줄링
   -  CPU 스케줄링은 여러 프로세스가 CPU 사용을 경쟁할 때, 어떤 순서로 CPU를 할당할지를 결정하는 것
-  Swapping
   -  메모리 관리 기법.
   -  대규모 시분할 시스템의 메모리 부족을 보안하기 위해 나온 기법.
-  Virtual memory
   -  메모리 관리 기법.
   -  대규모 시분할 시스템의 메모리 부족을 보충하기 위해 나온 기법.

보통 사용자가 터미널 등을 통해 컴퓨터를 사용하는 대화형 시스템이다.

<br>

<br>

## 1.5 Operating-System Operations

-  운영체제는 인터럽트 구동방식으로 동작한다.
   -  실행할 프로세스가 전혀없고, 입출력 도 없으면 메모리에 있으며 대기
   -  이때 운영체제를 동작 시킬 수 있는 것이 trap, exception 같은 소프트웨어 인터럽트이다.
-  exception 처리 루틴을 처리하며 운영체제가 동작하게 된다.
-  [exception]
   -  씨피유가 일반적 명령을 실행하며 발생하는 오류 이다. 대표적인 예로 나눗셈 명령을 실행하며 나누는 수가 0인경우 Divcice zero 라는 익셉션이 발생한다.
-  [Trap]
   -  트랩명령이라는 특수한 명령을 발생하며 일어나는 소프트웨어 인터럽트이다.
   -  대부분의 씨피유는 트랩명령을 가지고 있고 이 명령의 실행 결과는 씨피유의 상태를 소프트웨어 인터럽트 발생 직후와 같이 바꾸는 역할, =인위적으로 소프트웨어 인터럽트를 발생시키는 역할이다.
   -  `응용프로그램이 운영체제의 역할을 호출할때 발생.`
-  대부분의 CPU는 듀얼모드를 가지고 있다. CPI 내의 특정 레지스터 값의 비트값에 의해 결정 이를 모드 비트라고 부른다.
   -  `모드비트 = 0  커널모드`
   -  모드비트 = 1 유저모드.
-  유저모드에서는 특권 명령을 실행 할 수 없다.
   -  커널모드는 특권 명령을

외부 인터럽트 = 하드웨어 인터럽트 (하드 웨어 장치가 CPU에가)

내부 인터럽트 = SW 인터럽트 = system call = Trap,exception (응용프로그램이 운영체제 에게)

<br>

<br>

## Dual-mode

<img src="{{site.url}}/images/os1/os12.png" style="zoom:60%;" />

(2) 트랩 명령을 실행한다. 소프트웨어 인터럽트가 발생한다. (3) user code에서 kerenl code로 분기되고 user mode에서 kernel mode로 변한다.

(4) 특권명령(커널코드)가 실행된다.

-  인터럽트가 발생하면 kernel 로 돌아간다.
-  즉 User program(job .) → Kernel program → User program(job .) → kernel program의 반복이다.
   -  User mode → Kernel mode → User mode → Kernel mode 이다.
-  이중 모드 운영 (Dual-mode operation)
   -  이것은 컴퓨터 시스템이 사용자 모드(User mode)와 커널 모드(Kernel mode) 두 가지 모드로 운영되는 것을 의미한다.
   -  이는 시스템이 일반 사용자의 작업과 시스템 자원을 관리하는 커널 간의 구별을 허용한다.
-  사용자 모드와 커널 모드 (User mode and kernel mode)
   -  사용자 모드는 사용자 프로그램이 실행되는 모드이며, 일반적인 응용 프로그램이나 서비스가 여기에서 실행된다.
   -  커널 모드는 운영 체제의 핵심 부분인 커널이 실행되는 모드이다. 커널은 시스템 자원을 관리하고 시스템 서비스를 제공한다.
-  모드 비트 (Mode bit)
   -  이것은 하드웨어에서 제공되는 비트로, 프로세서가 현재 어떤 모드에서 실행 중인지 나타낸다.
   -  이 비트는 사용자 모드와 커널 모드 사이를 전환하는 데 사용된다.
-  권한이 있는 명령어 (Privileged instructions)
   -  일부 명령어는 커널 모드에서만 실행할 수 다. 이러한 명령어는 시스템 리소스에 접근하거나 시스템 상태를 변경하는 등의 특권이 있다.

<br>

<br>

## 1.6 Process Management

-  프로세스란 실행 중인 프로그램이다. 시스템 입장에서는 작업의 단위이다.
   -  프로그램은 수동적 의미, 프로세스는 능동적 의미
-  프로세스는 작업을 수행하기 위해 자원이 필요하다. 자원이란
   -  CPU, 메모리, 입출력(I/O), 파일 등
   -  초기화 데이터
-  프로세스 종료는 자원을 회수하는 과정이다.
-  시스템에는 다수의 프로세스가 있으며 하나 또는 여러개의 CPU에서 동시에 실행된다.
   -  동시 실행하는 것을 멀티플렉싱(타임쉐어링, 멀티프로그래밍)이라 한다.

<br>

<br>

## Process Management Activities

-  운영체제는 프로세스에 대한 제반 관리 책임이 있다.
-  프로세스를 생성하고 삭제한다.(모든 프로그램의 실행과 종료를 책임진다.)
   -  프로세스의 실행을 잠시 멈추었다가 재개하는 기능을한다.
   -  프로세스간 동기화 기능을 제공
   -  하나의 프로세스는 다른 프로세스에 대해 독립적이지만 때로는 동기화 할때가 있다. 이때 동기화 수단을 제공
   -  프로세스들은 실행중에 통신이 필요한 경우가있다. 프로세스간의 통신을 아이피씨라고 하며 운체는 통신 수단을 제공
   -  프로세스는 제한된 자원을 두고 경쟁하는 관계이다. 교착상태가 발생할 수 있는데 이를 해결하는 매커니즘을 제공한다.

<br>

<br>

## 1.7 Memory Management

-  디스크에다가 일정한 영역의 파일을 저장하는 것은 쉽지 않다.

메모리 관리

-  컴퓨터의 동작에서 모든 데이터는 처리 전 후에 메인 메모리에 존재해야한다.
   -  모든 명령은 실행되기 위해서 먼저 메인 메모리에 적재되어야한다.
   -  이를 폰노이만, 스토어 프로그램 방식의 컴퓨터라고 했다.
-  메인 메모리의 핵심은 언제 어디에 내용을 저장할 것인가이다. 이는 씨피유 활용도를 높이고 사용자 응답시간을 높이는 방향으로 결정이 이루어져야한다.
   -  메모리에 어느 영역이 누구에 의해 사용되고 있는지 관리해야한다.
   -  어느 프로세스가 메모리로 이동해야하는지 어느 프로세스가 나와야하는지 결정해야한다.
   -  메모리 공간의 할당과수행을 결정해야한다.

<br>

<br>

## 1.8 Storage Management

보조 기억 장치 관리

-  운체는 정보의 저장에 대한 논리적 일관된 비율을 사용자에게 제공한다.
-  디스크나 테이프 드라이브등 특정매체에 관계없이 파일이라는 논리적 저장단위를 의미한다.
-  파일 사용은 자장장치의 속도 용량 접근방식과 무관하게 데이터 접근 사용 가능하다.
-  운영체제는 파일 사용을위해 파일 시스템을 관리하낟.
-  파일시스템을 통해 파일단위로 저장, 디렉토리를 통해 파일을 분류 할 수 잇다.
-  어느 사용자가 어느 파일에 접근제어를 제공한ㄷ.
   -  파일과 디렉토리를 생성 삭제 기능
   -  파일과 디렉토리의 내용을 조작할 수있는 수단 제공
   -  파일의 내용이 저장장치의 특정위체에 저장될수있도록
   -  파일의 내용이 의도치않게 삭제되는 것을 방지 위해 테이블 스트리지를 제공

<br>

<br>

## Mass-Storage Management

```
****
```

대용량 저장장치 제공

-  컴퓨터의 전체 성능은 디스크 서브시스템과 알고리즘에 영향을 받는다.
-  피시의 하드디스크를 에스에스디로 교체 처럼
-  보조기억장치의 성능은 매우 중요하다.
-  이와 관련된 운영체제의 기능은 빈공간 관리 저장장치할당 디스크 스케쥴링이있다.
   -  어느 공간이 빈공간인지 운체가 관리
   -  새로운 파일을 저장 한 경우 빈공간중 어느 공간에 할당할지 운체가 관리
   -  하드디스크의경우에 한 파일 저장위치에 따라 해당 파일 접근 시간이 많이 차이 날수 있다.
   -  운체는 디스크 입출력할떄마다 어떻게 읽는것이 효율적인지 고민 = 디스크 스케쥴링
   -  광학저장장치 마크네틱 테이프등 보조기억장치를 사용하는 경우 하드디스크보다 용량은 크지만 접근속도는 느리다. 운체는 이에 대한 관리 기능도 가지고 있다.



<br>

<br>

## Performance of Various Levels of Storage

하드디스크를 제외하면 반도체 기술 기반이다.

register - compiler가 관리 (특정 cpu명령 데이터를 어느 레지스터인지)

cache - CPU가 관리

main memory - 운영체제가 관리

Solid state disk - 운영체제가 관리

magenetic disk  - 운영체제가 관리

<br>

<br>

## I/O Subsystem

-  운영체제가 입출력 장치의 번거로움을 대신 해준다.
   -  운영 체제의 한 가지 목적은 하드웨어 장치의 특이성을 사용자로부터 숨기는 것
-  특정 하드웨어 장치에 대한 드라이버
   -  브랜드에 관계없이 특정한 입출력 장치에 일관된 인터페이스 모드를 갖고있다.

개별 하드웨어 장치의 특수성을 사용자로부터 숨기는것이다.

출력 장치는 다양하고 방법도 다르다.

-  사용자는 개별 입출력 장치에 맞춰 프로그래밍 하는것은 매우 어렵다.
-  운체는 사용자 프로세스 대신에 입출력을 대신 하는 것을 대표적 기능으로하고있다.
-  운체는 입출력 메모리 공간 관리(버퍼링, 캐싱, 스풀링)
   -  버퍼링 = 입출력 중 데이터를 저장 장치의 임시로 저장하는 것
   -  캐싱 = 저속 저장장치를 고속 저장장치에
   -  `스풀링 = 입출력 데이터를 직접 장치에 보내는 대신 메모리 공간에 저장하고 이를 나중에 일괄 처리하는 방식`

모두 메모리에 일정 공간이 필요하고 운체는 이 공간을 권리한다.

-  운체는 특정 출력장치를 읽고쓰는 기능을 가진 프로그래밍인 디바이스 드라이버를 제공한다.
-  디바이스 드라이버를 통해 일반 프로세스의 입출력 작업을 대응 할 수 있다.

범용 디바이스 드라이버(커널 내에 있음)를 제공, 특정 하드웨어에 상관없이 입출력 장치 사용 가능

<br>

<br>

## 1.9 Protection and Security

-  보호와 보안의 차이점.
-  Protection(보호)
   -  내파일을 읽지 못하도록 막는것, 즉 친구가 저장해 둔 파일을 삭제 못하도록 하는 것이다.
   -  사용자를 구분하고 누가 무엇을 할 수 있는 지를 결정하는 것이다.
-  Security(보안)
   -  시스템을 외부 내부 공격으로부터 방어
   -  바이러스 웜 도스 공격으로부터 방어
   -  시스템은 사용자 구분. 사용자가 어떤일 할수있는지
      -  유저아이디를 통해 접근파일, 프로세스를 연관시킴
      -  필요한 경우 그룹아이디 생성

<br>

<br>

## 1.11 Computing Environments- Traditional

계산 환경 - 전통적

-  다수의 독립적인 범용 컴퓨터와 제한적 네트환경으로 이루어져있었다.
-  원격성이 없었다.
-  회사에서는 터미널 을 통해 사용을 원격성, 이동성이 낮았다.
-  현재 추새는 원격접근을 다양한 형태로.
-  [Network computers] 회사에서는 포털로 내부 접근(Thin client) 유지보수, 보안이 필요한경우 대체하고있다.
-  피시와 동기화하여 무선 네트워크 사용
-  네트워크는 어디에나 사용가능, 많은 가정에서 외부 공격 방화벽(firewall)도 가능.

<br>

<br>

## Computin Mobile

-  모바일은 스마트폰 태블릿등 이동가능 장치
-  랩탑과 비교하면 크기 용량등 전체적인 기능을 포기한 대신 접근성을 얻었다.
   -  하지만 이제는 성능도 랩탑수준
-  GPS , 자이로스코프 등 랩탑에 없는 기능도 추가
-  802.11 네트워크나 휴대전화 네트워크 사용

<br>

<br>

## Distributed

물리적 떨어져있는 컴퓨터의 집합. 사용자가 다양한 자원을 접근하도록 네트워크로 이루어져있음.

네트워크는 가장 단순하게 본 2개이상의 컴퓨터간의 통신 경로이다.

통신프로토콜은 TCP/IP 모든 운영체제는 이 프로토콜을 제공

네트워크를 통한 파일공유, 프로세스들의 메세지 교환등 가능

<br>

<br>

## Client-Server(분산 시스탬)

-  PC의 성능 향상, 가격 적어짐에대해 중앙집중식 시스템의 터미널이 PC로 대체
-  서버시스템으로 동작하게 되었고 특별한 분산시스템을 클라이언트-서버라고 함
-  서버의 종류는 계산서버와 파일서버로 나눌 수 있음
   -  인터페이스 제공, 요청 처리, 클라이언트에 결과 반환
   -  계산 서버의 예로 데이터베이스 서버
   -  파일 서버는 생성 제거 갱신의 인터페이스 제공
      -  웹브라이저에게 파일을 전달하는 웹서버

<br>

<br>

## Peer to Peer

-  분산시스템의 또다른 형태, 클라이언트와 서버가 구별 되지 않는다.
-  제공, 요청에 따라 둘다 동작한다.
   1. 네트워크 참여 : 노드는 잘 알려진 검색 서비스에 내 서비스 등록
   2. 검색 서비스 대신 특정 디스커버리 프로토콜에 참여

<br>

<br>

## 가상화

-  `운영체제가 다른 운영체제 내에서 하나의 응용프로그램으로 실행된다.`
-  `기존의 에뮬레이션(소스 cpu가 다를때 고급, 또는 중급 수준의 형태로 되어있을 때 인터프리터 방식이다.) 가상화의 한 기법이다.`
-  가상화는 같은 CPU를 사용하지만 다른 운영체제의 경우이다.
   -  자원 사용권리를 서로로부터 보호한다.

<br>

<br>

## Cloud Computing

계산, 저장, 응용 또한 네트워크로 제공

-  클라우드 컴퓨팅은 가상화를 기반으로 하기 떄문에 가상화의 논리적 확장이다.

아마존은 페타바이트 급의 저장장치를 인터넷 상에서 누구나 사용

퍼블릭 (서비스 지불가능한 사람이라면 누구나) 프라이빗(한회사 내에서만 사용가능) 하이브리드(공공, 사설 서비스)

SAAS - 인터넷 사용가능한 응용 PAAS - 인터넷을 통해 제공되는 소프트웨어 스텍 IAAS- 저장장치

<br>

<br>

클라우드 하부에는전통적인 운체 존재 그위에는 사용자 프로세스가 실행되는 가상기계관리하는 가상버츄얼 머신 모니터가있고 그 위로는 클라우드 관리 도구가 있어서 버츄얼 머신 모니터를 관리한다.

주어진 클라우드의 자원을 관리하면서 구성요소에 대한 인터페이스를 제공하므로 새로운 형태ㅢ 운영체제로 볼 수 있다.

이는 아이에스에스 공중 클라우드 그림이다.

<img src="{{site.url}}/images/os1/os13.png" style="zoom:60%;" />

<br>

<br>

## Real - Time 임베디드 시스템

-  자동차 엔진, 로봇 등 내장형 시스템이다.

실시간 임베디드 시스템은 최근 많이 사용되는 시스템

자동차,엔진,로봇,등등

특정한 작업만을 수행 따라서 운체도 제한된 기능만 제공

어떤 운체는 리눅스와같은 범용 운체를 가지며 특정 명령 수행

다른 시스템은 내장향 운영체제를 갖고있는 하드웨어 체제

다른 시스템은 운영체제가 없이 Oses 이라고하는 운영체제 칩을 가진다.

반드시 시간 내에 처리해야한다.!!!!!