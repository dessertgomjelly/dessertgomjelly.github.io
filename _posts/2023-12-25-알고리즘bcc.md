---
layout: single
title: "[알고리즘으로 단단해지기] 4.그래프 BCC (Biconnected graph)" 
categories: Algorithm
tag: [Graph,DFS,BCC]
use_math: true #수학 공식 가능하게
sidebar:
    nav: "counts"


---

<style>
  body {
    font-size: 16px; /* 폰트 사이즈 조절 */
  }
</style>



# BCC (Biconnected graph)

BCC는 둘 이상의 정점들이 모두 연결되어 있는 그래프이다. 

SCC는 directed graph일 때 사용하지만, BCC는 undirected graph일 때 사용할 수 있다.

<br>

<br>

### 분절점 (Articulation point)

분절점이란 무방향 그래프 (undirected graph)에서 한 정점을 삭제 했을 때 그래프가 2개 이상으로 나누어지는 정점을 의미한다.

- 2를 삭제한다면 그래프가 2개로 나뉜다.

<img src="{{site.url}}/images/2023-12-25-알고리즘bcc/Untitled.png" style="zoom:40%;" />

<br>

<br>

- 6을 삭제하면 그래프가 2개로 나뉜다.

<img src="{{site.url}}/images/2023-12-25-알고리즘bcc/Untitled 1.png" style="zoom:40%;" />

이처럼 한 정점을 삭제했을 때 그래프가 둘 이상으로 나뉜다면, 그 정점을 `분절점 (Articulation Point)` 이라 한다.

<br>

<br>

### dfn (Depth-first number)

BCC에서는 `dfn(depth-first number)` 을 통해 분절점을 구할 수 있다.

- dfn은 `dfs()`를 돌렸을 때 지나는 vertex마다 숫자를 부여하는 것이다.

Depth-First Search (DFS)를 통해 그래프를 탐색할 때, 각 vertex에 대해 **`dfn`** 값을 부여하는 것은 그 vertex가 처음으로 발견된(discovered) 시간을 나타낸다. 이 값은 그래프를 탐색하는 동안 순서대로 증가하며 할당된다.

예를 들어, 다음과 같은 그래프가 있다고 가정해봅시다:

```

   1 --- 2 --- 3
   |         |
   4 --- 5

```

DFS를 수행하면서 각 vertex에 **`dfn`** 값을 할당하는 순서를 살펴보겠습니다.

1. **시작 (예: 1):**
    - **`dfn`**: 1 (처음 발견된 시간)
2. **인접한 vertex로 이동 (예: 2):**
    - **`dfn`**: 2
3. **다시 인접한 vertex로 이동 (예: 3):**
    - **`dfn`**: 3
4. **다시 이전 vertex로 돌아와서 다른 방향으로 이동 (예: 4):**
    - **`dfn`**: 4
5. **인접한 vertex로 이동 (예: 5):**
    - **`dfn`**: 5

<br>

<br>

아래 그래프에서 $3$을 root vertex로 잡고, 시작을 $4$번 vertex로 생각하고 dfs를 하면 다음과 같다.

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%202.png)

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%203.png)

- Spanning Tree 형태로 dfn을 구하면 다음과 같다.

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%204.png)

- 위 트리에서 확인할 수 있는 특징은 다음과 같다.
    - `root node`에서 `leaf node`로 가는 경로는 `ancestor↔descendant` (조상 ↔ 후손) 관계이다.
        - 모든 `descendant`의 `dfn`은 `ancestor`의 `dfn`보다 **크다**.
            - $1$ vertex의 `dfn`은 모든 `ancestor`의 `dfn`보다 **크다**.
            - $3$ vertex의 `dfn`은 모든 `descendant`의 `dfn`보다 **작다**.
        - 즉, $`u\text{ } is\text{ } ancestor\text{ } of\text{ } v\text{ } in\text{ } the\text{ } depth-first\text{ } spanning\text{ } tree`$일 때  $dfn(u) < dfn(v)$ 이다.

<br>

<Br>

### Back Edge

BCC에서의 `non-tree edge`는 전부 `back edge` 이다.

- Undirected graph에서의 edge 종류는 다음과 같다.
    - **Tree Edge**
    - **Backend Edge**
- 아래 그래프와 트리에서 `Back Edges` 부분은 다음과 같다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%205.png)
    
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%206.png)
    
- 이 Back edge를 활용하면 분절점을 쉽게 구할 수 있는데 분절점의 특성은 다음과 같다.
    - 한 vertex를 삭제했을 때 두 개의 그래프로 분할되어야 한다.

<br>

<br>

- depth-first spanning tree에서 분절점을 찾는 방법은 두 가지가 있다.
    1. 두 개 이상의 child vertex를 가진다면 분절점이다.
        - 즉, 위 tree에서 root node는 분절점이다.
          
            ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%207.png)
        
    2. low() 를 이용하여 구하는 것이다.
       
        

<br>

<br>

### low()

$low(u)$ 우리는 결국 vertex $u$가 도달할 수 있는 가장 작은 dfn을 구해야 한다.

- $low(u)$
    - vertex $u$가 자신이 가장 낮은 dfn수로 가기 위한 방법은 3가지 중 가장 작은 값을 구하면 된다.
        1. $dfn(u)$
            1. 자신의 dfn 수이다.
            
            ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%208.png)
            
        2. $min\{{low(w) | w\text{ }is\text{ }a\text{ }child\text{ }of\text{ }u\}}$
            1.  $u$의 child vertex인 $w$들의 $low$ 값 중 가장 작은 값이다.
        
        ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%209.png)
        
        1. $min\{{dfn(v)|(u,v)\text{ }is\text{ }a\text{ }back\text{ }edge\}}$
            1. $u$의 ancestor인 $v$로 이어지는 back edge 중 가장 작은 값이다.
    
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2010.png)
    
    - 위 규칙을 수식으로 표현하면 아래와 같다.
    
    $\hspace*{-40pt} low(u) = \min\{dfn(u) \}, \\$
    $\hspace*{114pt} \min\{ low(w) \,|\, w \text{ is a child of } u \}, \\$
    $\hspace*{136pt} \min\{ dfn(v) \,|\, (u, v) \text{ is a back edge } \} \}$

<br>

<br>

$dfn$과 $low$를 구해보면 다음과 같이 구해질 것이다.

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2011.png)

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2012.png)

<br>

<br>

이제 두가지 규칙을 통해 분절점을 구할 수 있다.

1. Tree에서 두 개 이상의 자식을 가질 경우 Articulation point이다.
2. $u$가 root가 아니고, 자식 vertex $w$의 $low(w) \geq dfn(u)$이면 Articulation point이다.

- $1$ vertex는 Articulation point이다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2013.png)
    

<br>

- $2$ vertex는 Articulation point가 아니다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2014.png)
    

<br>

- $4$ vertex는 Articulation point가 아니다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2015.png)
    

<br>

- $7$ vertex는 Articulation point이다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2016.png)
    
    <br>
    
- $6$ vertex는 Articulation point가 아니다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2017.png)
    
    <br>
    
- $5$ vertex는 Articulation point이다.
  
    ![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2018.png)
    

<br>

- $3$은 root이므로 Articulation point이다.

정리해보면, $\{u\,|\,low(w)\geq dfn(u)\} + \text{root}$ 이므로, 분절점은 다음과 같다.

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2019.png)



<br>

<Br>



### Code

BCC는 dfs를 한 번만 돌리면 dfn, low, articulation point, BCC를 전부 구할 수 있다. 즉, $O(n+m)$의 시간복잡도를 가진다.

Depth-first number 구하기

```cpp
int visit[MAX_VERTEX]; // FALSE로 초기화 
void dfs ( u )
{
	visit[u]=TRUE;
	
	for ( w = graph[u]; w; w = w->link )
	  if ( !visit[w] )
			dfs ( w );
	}
}

int dfn[MAX_VERTEX];// -1로 초기화
int low[MAX_VERTEX];// -1로 초기화
int num = 0;

void dfs1 (u,v) //v는 u의 부모
{
	dfn[u] = num ++;

	for ( w = graph[u]; w; w = w->link)
		if (dfn[w] < 0 )
			dfs1 (w,u);
	}
}
```

<br>

<br>

low(u) 구하기

```cpp
void dfs2 (u,v)// v는 u의 부모
{
	dfn[u] = low[u] = num ++;

	for( w = graph[u]; w; w = w ->link )
		if (dfn[w] < 0 ) {
			dfs (w, u);
			low[u] = min (low[u], low[w]);
	}
	else if ( w != v)
		low [u] = min (low[u], low[w])
}
}
```

<br>

<br>

Articulation Point 구하기

```cpp
void dfs3(u,v)//v는 u의 부모 
{
	dfn[u] = low[u] = num++;

	for ( w = graph[u]; w; w = w->link )
		if ( dfn[w] < 0 ) {
		dfs3 ( w, u );
		low[u] = min (low[u], low[w]); 
		if ( low[w] >= dfn[u] )
        print (“u: articulation point”);
    }
    else if ( w != v )
      low[u] = min (low[u], low[w]);
  }
}

```

<br>

<br>

Biconnected Components 구하기 

```cpp
void dfs4 (u, v) //v는 u의 부모
{
	dfn[u] = low[u] = num++;
	for(w=graph[u];w;w=w->link) 
	if ( dfn[w] < 0 ) {
	dfs4 ( w, u );
	low[u] = min (low[u], low[w]); 
	if ( low[w] >= dfn[u] ) {
	  print(“new bicon:”);
	  do {
			pop (&x, &y);
			print ( <x, y> );
		} while ( x != u || y != w ); 
	}
}
   else if ( w != v )
   low[u] = min (low[u], low[w]);
  }
}
```

![Untitled](%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%8B%E1%85%B3%E1%86%B7%206789eb130cf0424384ee63cde4843e89/Untitled%2020.png)