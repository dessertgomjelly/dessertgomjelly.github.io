---
layout: single
title: "[운영체제] Chapter 2: Operating System Structures" 
categories: Operating_Systems
tag: [Operating_Systems]
use_math: true #수학 공식 가능하게
sidebar:
    nav: "counts"

---

<style>
  body {
    font-size: 15px; /* 폰트 사이즈 조절 */
  }
</style>




**[참고자료]** **[Operating System Concepts 에센셜]** 저자(글) · Abraham Silberschatz, Peter Baer Galvin ,  Greg Gagne 번역 조유근, 박민규 , 고건
{: .notice--danger}



# Chapter 2: Operating System Structures

<br>

<br>

## 2.1 Operating System Services

-  user interface

   -  Command-Line interface(CLI)

      -  1인 컴퓨터 이전에는 한 컴퓨터에 다중사용자가 있었다. 각 컴퓨터를 사용하기 위한 수단이 단말기(teminal) 이다.
      -  모니터와 키보드를 합쳐 놓은 장치인 단말기를 사용하기 위한 인터페이스이다.
      -  한줄씩 명령, 입력, 실행 한다.

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/34ef22bb-5199-4bb6-b04b-beea7df6fcd2/Untitled.png)

   -  Graphics User interface(GUI)

   -  Batch interface

-  운영체제는 Program 실행을 한다.

   -  운영체제는 프로그램을 하드디스크로부터 읽어와 메모리에 로딩하여 실행
      -  디스크 등의 보조기억 장치에 있는 프로그램을 메모리로 적재, 정상 비정상적 과정까지 관여

-  입출력 Operations

   -  실행중인 프로그램은 모두 입출력을 한다.
   -  입출력은 응용프로그램이 직접 하지 않는다. 운영체제가 대신한다.
      -  응용 프로그램이 입출력을 원할 경우, 운영체제에게 요청을 하고 운영체제는 해당 작업을 처리하여 결과를 반환한다.

-  File-system manipulation

   -  파일 디렉토리를 읽고 쓰고, 생성, 삭제, 검색, 리스트, 접근권한 관리 등의 서비스 제공

-  **Communications**

   -  데이터 주고받는 것만 통신이 아니라 [한 프로그램이 다른 프로그램에 영향을 미쳐야하는 경우](프로세스 동기화) 또한 통신의 한 형태이다.
   -  IPC
      -  두개의 프로세스가 같은 컴퓨터내에서 통신
      -  통신 수단 제공
         -  shared memory
         -  through message passing
   -  Network
      -  네트워크 원격 제어 컴퓨터

-  Error detection

   -  응용프로그램은 오류를 생성한다 따라서 항상 믿을 수 없다.
   -  운영체제는 여러 유형의 오류에 대해서 지속적으로 모니터링 한다.
   -  오류의 종류
      -  CPU, Main Memory, I/O등의 하드웨어 오동작
      -  응용프로그램(소프트 웨어)의 논리적 오류
         -  적절히 통제 해야 한다.
   -  디버깅
      -  오류발생 원인을 찾는 과정

-  자원할당

   -  자원이란 응용프로그램에 필요한 하드웨어를 의미 (cpu, 메모리, …)
      -  특징으로는 대부분의 자원은 공유할 수 없다. 공유가 불가능하기 때문에 한 프로세스가 끝나야 다음 사용이 가능하다.
      -  Job, process가 자원을 필요로 한다. 운영체제는 이 자원을 적절히 분배하는 일을 한다.
   -  CPU, Main Memory, Disk 공간 등은 별도의 할당 기법을 사용한다.
      -  모든 자원 할당의 기준은 효율성과 공정성이다.

-  Accounting

   -  자원 사용의 history를 기록한다. 이후의 자원할당 정책, 사용자의 과금에 사용

-  Protection (보호)

   -  다중시스템 , 여러 프로세스동작시에 모든 시스템에 대한 접근을 통제하는 것이 보호이다. 보호 접근제어 수단을 제공한다.

-  Security (보안)

   -  시스템의 외부자로부터 보안을 유지하기 위해서는 사용자 인증이 필요하며, 이는 외부 I/O 장치에 대한 무효한 접근 시도로부터 방어한다.

<br>

<br>

## A View of Operating System Service

-  user and other System programs(운영체제 일부긴 하지만 커널포함 x, 파일 관리자 같은거) 사용자 프로그램의 (최상단)

======================================================================

-  사용자 인터페이스(GUI, Batch, CLI) 등 특수 목적의 사용자 프로그램

====================여기서 부턴 커널 ======================================

-  시스템 콜 인터페이스(독자적인 소프트웨어 프로그램은 아니고 응용프로그램이 하단의 운영 체제 기능을 호출하는데 사용하는 프로그래밍 인터페이스)
-  커널 ( 서비스 제공 , 하드웨어 바로 위에서 동작)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/70ce713c-5ac0-484e-9795-3b4c253a5940/Untitled.png)

<br>

<br>

## 2.2 User Operating System Interface - CLI

CLI (사용자 운영체제 인터페이스)

-  스크린과 키보드장치를 기반으로 하는 사용자 인터페이스이다.
   -  사용자가 키보드 입력을 통해 명령 입력함으로써 프로그램 실행 가능하다. 보통 한줄에 명령 하나씩 하는데 명령 입력줄을 커맨드 라인이라고 한다.
-  출력은 모두 화면을 통해 한다.
   -  키보드 입력을 통해 입력을 받고 입력에 해당하는 프로그램을 실행하는 프로그램을 Command interpreter 라고한다.
   -  커맨드 인터프리터는 커널내에 구현 될 수도 있고, 시스템 프로그램일수도 별도의 응용프로그램으로 적용되기도 한다.
-  응용프로그램의 형태로 제공되는 CLI는 취향에 따라 한 시스템에서 여러종류가 제공되기도 하는데 이를 셸이라고 한다.
-  본 셸 ( 유닉스 운영체제의 CLI를 뜻한다.)
   -  프롬포트를 찍는다. 프롬포트에 대해 원하는 입력, 적잘한 프로그램 실행, 다음 명령을 입력 받기위해 프롬포트를 출력한다. 사용자가 프로그램 사용하는동안 계속 반복한다.
   -  사용자로부터 입력을 받고 이를 해석해서 실행한다
   -  명령이란 응용프로그램인 command interpreter 가 자체적 처리하는 내장 명령일수도있고, 다른 프로그램의 이름이여서 인터피리터가 이를 실행하기만 하면 되는 형태일 수도 있다.
   -  [내장 명령] 파일 및 디렉토리 관리, 프로세스 제어, 환경 변수 설정 등과 같은 기본적인 작업, (cd, mkdir)
   -  [외장 명령] 이 경우 프로그래머가 쉘의 이름을 갖는 프로그램을 생성함으로써 기존 쉘에 수정이 없이 새로운 명령을 만들어 낼 수 있다.

<br>

<br>

## GUI(Grapical User Interface)

-  데스크탑이라는 윈도우 시스템을 이용한다. 모니터가 그래픽이 표현이 가능하다.
-  키보드 마우스가 있는 경우에 컴퓨터의 모든 자원을 아이콘으로 가능하다.
-  프로그램의 실행은 윈도우로 표시.

하고자하는 작업에 더빨리 접근하려면 CLI 몇 시스템에서는 몇몇 기능을 CLI로만 가능하다. 보통 반복적으로 해야하는 작업을 쉽게 할 수 있는 프로그래밍 기능을 제공한다.

-  몇몇 기능.
   -  자주 사용되는 작업이 일련의 명령으로 이루어져있으면 이 과정을 파일로 저장하면 파일로 프로그램을 실행하는 것을 셸 스크립트라고 한다.

CLI

유닉스에서는 쉘 스크립트가 많이 사용된다. 윈도우즈는 GUI만 이용하길 원하는 경우도있다.

사용자 인터페이스는 실질적인 시스템 구조에 포함되지 않는다. 따라서 유용학 친절한 사용자 인터페이스를 설계하는것은 운체의 기능이 아니다.

<br>

<br>

## 2.3 System Calls

-  운영체제가 제공하는 서비스를 이용할 수 있도록 하는 프로그래밍 인터페이스를의미.
-  C나 C++같은 함수 형태로 제공되며 응용프로그램은 원하는 시스템콜을 호출하여 커널 서비스를 제공 받을 수 있음.

<br>

<br>

## 하나의 응용프로그램은 어떻게 시스템콜을 사용할까?

파일 복사 그림을 보자. 이 프로그램은 원본파일의 이름과 새파일의 이름을 사용자로부터 얻어 복사하는 기능을 수행한다.

복사할 원본파일의 이름을 사용자로부터 얻어야함. (“프롬포트 : 파일 이름을 입력하세요”)하고 사용자로부터 입력받는다. 이때 메세지 출력도 시스템콜이고, 파일 이름을 입력받을때 키보드 입력도 시스템 콜이다. 즉 2번의 시스템 콜이 이루어진다.

다음은 복사본 파일의 이름을 얻어야한다. 이과정도 두번의 시스템콜이 일어난다.

파일을 오픈하는것도 시스템콜을 통해야한다. 만일 입력받은 일음의 파일이 없으면 오픈과정에서 오류가 발생하고 프로그램 종료해야하는데 이때도 시스템 콜을 통해 종료해야한다.

복사본 생성도 시스스템 콜을 통해야한다. 이미 존재나느 파일 생성시에도 오류이므로 시스템콜을 통해야한다.

읽기와 쓰기를 반복하는데 이또한 시스템콜이다. 복사 파일 크기 1메가 바이트 한번에 1킬로바이트씩 읽어서 쓴다면 이 과정은 1000번을 반복해야함. 한번 읽고 쓰는데 두번의 시스템 콜이 필요하기때문에 전체적으로 약 2000번의 시스템콜이일어난다.

파일 닫기 복사완료 메세지 프로그램 종료 동작도 시스템 콜이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/dea12ed0-463f-4f54-ad9f-2397c16ab8dc/Untitled.png)

<br>

<br>

## System Calls (Cont’d)

시스템 콜은 응용프로그램이 호출할수있는 함수형태여서 응용프로그램이 직접 호출하여 사용할 수 있다고했다.

하지만 실제 응용프로그램 개발자는 API를 이용해서 프로그램을 작성한다.

-  API는 시스템콜보다 높은 수준의프로그래밍 인터페이스이다.
-  System call <-> API
   -  파일의 내용을 읽는 시스템콜이 있다고 가정하면
   -  API에는 비슷하지만 조금더 쉬운 형태의 함수가 존재한다. API 함수를 호출하면 다시 해당 시스템콜을 호출하는 관계이다.
-  결론적으로 개발자에겐 두가지 옵션 있다. 시스템콜 호출, 관련기능을 하는 API 함수를 호출, 선택은 개발자의 몫
-  많이 사용 되는 API
   -  윈도우에는 윈32
   -  유닉스는 POSIX, (대부분 유닉스 리눅스 MOS는 포직스를 제공한다.)
   -  JAVA API
-  API 목적
   -  프로그램의 소스코드 수준의 호환성이 유지된다
   -  시스템 콜은 자세한 명세가 필요해서 API보다 사용이 어렵다.

<br>

<br>

## Example of Standard API

-  POSIX API의 예
   -  READ() 함수. 리눅스 및 대부분 운영체제에서 사용 가능하다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/a6f6a32b-3611-4709-bc81-5f7dadb35e4c/Untitled.png)

-  유닉스 운영체제의 시스템콜 POSIX API
-  입력 장치로 부터 읽는 동작
-  헤더파일을 먼저 include 해야함.
-  read는 API이자 함수이기 때문에 파라미터, return 를 갖고있다.
-  유닉스에서는 파일이나 장치나 하나의 파일로 본다.
   -  파일을 읽을 때, 키보드 I/O 할때 read() 를 사용한다.
      -  int fd - 파일을 읽을때 정수를 갖게되는데 이게 file descriptor이다.
      -  buffer - 읽은 데이터를 저장할 버퍼의 포인터
      -  size-t count - 읽을 최대 byte 수
-  음수 return은 실패이고, 양수나 0 은 실제 읽힌 바이트 수를 의미한다.

fd 라는 오픈된 파일에서 count bite 만큼 읽어서 버퍼가 가르키는 포인터로 복사한다.

실제 읽기 한 후에 읽은 바이트수를 리턴하는 것으로 끝난다.

<br>

<br>

## 시스템 콜의 동작 방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/b76fbc8b-4d88-47e3-b233-1117077c860a/Untitled.png)

(1) 유저에서 open api 함수(system call) → (2) 커널로 분기하기 위한 trap 명령어 실행됨

(2)trap에 의해 user 에서 커널 모드로 바뀜. #모든 시스템 콜은 동작에 해당하는 정수값이 정의되어있다. open에 해당하는 정수값을 같이 넘긴다.

(2) 각 번호의 시스템 콜을 갖고있는 포인터를 가지고 있다.

(3) 포인터를 따라 open을 수행한다.

오픈의 결과값이 file descriptor이다.

(4) 리턴한다.

(5) user 모드로 돌아간다.

```
사용자 프로그램이 시스템 콜을 호출할 때 내부적으로 트랩 명령어를 사용하여 커널로 제어 흐름을 전달.
```

잘 생각해보면 1장에서 ISR처리랑 동작이 매우 유사하다.

<br>

<br>

## 파라미터 전달방법

1. 파라미터를 CPU 레지스터에 담아서 전달한다. (미리 약속)
   -  레지스터가 모잘라서 파라미터를 다 못담을 수 도 있다.
   -  파라미터 크기가 가장 작은 경우에 가능
2. 파라미터를 메모리 영역을 잡아서 파라미터를 담아 둔다. 커널에게는 파라미터가 담긴 메모리 시작 주소만 전달한다.
3. 스택을 사용
   -  시스템 콜 시작할 때 파라미터를 스택에 푸쉬 → 커널로 넘어간다. → 스택을 꺼내서 사용
   -  2번과 유사하지만 스택을 사용한다는 것이 차이점

-  모든 응용프로그램(프로세스)는 스택을 가지고 있는데 스택에 담에서 전달하면 커널이 꺼내 쓸 수 있다.

2,3 번 방법은 파라미터 크기에 구애 받지 않는 방법이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/d1894202-a73a-4840-81cc-b4b6f77857a7/Untitled.png)

<br>

<br>

## Standard C Library Example

-  표준 C 라이브러리와 시스템 콜의 관계
   -  C 프로그램 개발환경이 갖춰진 시스템은 표준 라이브러리 함수를 사용한다.
   -  응용프로그램이 pintf()를 호출하면, C 라이브러리는 이 호출을 가로쳐서 응용프로그램에 필요한 시스템 콜을 한다. wirte()라는 시스템 콜이 호출된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/0fecd90f-e2a1-4661-879d-0dafca2b73f9/Untitled.png)

<br>

<br>

## 2.4 Types of System Calls

리눅스 커널의 경우 시스템 콜의 개수가 300가지가 넘는다.

다음 유형이 있다.(프로세스 제어, 파일 조작, 장치 조작, 정보의 유지보수, 통신 보호)

1. 프로세스 생성 (Create Process)

   :

   -  새로운 프로세스를 생성
   -  새로운 프로세스를 실행하기 위해 필요한 자원을 할당하고 초기화

2. 프로세스 종료 (End, Abort)

   :

   -  프로세스를 종료하거나 중단
   -  자원을 정리하고 다른 프로세스에게 리소스를 반환

3. 프로세스 속성 설정 및 얻기 (Get/Set Process Attributes)

   :

   -  실행 중인 프로세스의 속성을 설정하거나 얻기
   -  예를 들어, 우선 순위, 권한 등의 속성을 설정하거나 확인

4. 시간 대기 (Wait for Time)

   :

   -  특정 시간 동안 프로세스를 대기
   -  주로 타이머 기능을 활용하여 프로세스를 특정 시간 동안 정지시킬 때 사용

5. 이벤트 대기 및 신호 (Wait Event, Signal Event)

   :

   -  특정 이벤트가 발생할 때까지 프로세스를 대기시키거나, 이벤트가 발생하면 해당 이벤트를 처리
   -  이벤트는 주로 입출력 작업 완료, 시그널 수신 등의 상황을 가리킴

6. 메모리 할당 및 해제 (Allocate and Free Memory)

   :

   -  프로세스가 메모리를 할당하거나 해제할 때 사용
   -  동적으로 메모리를 할당하고 해제하여 프로세스가 필요한 만큼의 메모리를 효율적으로 사용

7. 메모리 덤프 (Dump Memory)

   :

   -  에러가 발생한 경우 메모리 덤프를 생성하여 해당 시점의 메모리 상태를 확인
   -  주로 디버깅 목적으로 사용

8. 디버깅 및 단계별 실행 (Debugger for determining bugs, single step execution)

   :

   -  프로세스를 디버깅하고 버그를 식별하는 데 사용
   -  단계별 실행이나 프로세스 상태 및 변수 확인 등의 작업을 수행

9. 락 (Locks for managing access to shared data between processes)

   :

   -  여러 프로세스 간에 공유된 데이터에 대한 접근을 관리하기 위해 락을 설정하거나 해제
   -  공유 데이터에 대한 동시 접근을 제어하여 데이터 일관성을 유지

<br>

<br>

## Example: MS DOS

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/47844aa5-bfab-4ddf-b030-10d25d45d039/Untitled.png)

-  프로세스 제어는 단일 태스킹 시스템과 다중 태스킹 시스템이 있다.
-  MS DOS는 단일 태스킹 시스템이다.
-  시스템 시작 직후 커널과 명령 해석기(command interpreter) 만 있다.
-  단일 태스킹 방식
   -  하나의 프로그램 시작 시 가능한 많은 메모리를 프로그램에게 제공하기 위해 일부를 프로세스에게 양보.
   -  명령 포인터를 프로그램의 첫번째 명령으로 설정하여 프로그램의 실행 개시, 종료(오류)시 트랩 발생
   -  어느 경우든 다음 이용을 위해 오류코드가 메모리에 저장되며 (오류 코드를 사용자나 다른 프로그램이 이용할 수 있도록)

<br>

<br>

## FreeBSD

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/e7de1c32-8661-406c-87ba-41d3b36c18b8/Untitled.png)

다중 태스킹 방식

-  사용자가 로그인하면 미리 지정해놓은 쉘이 수행. 쉘은 명령해석기이다.
-  쉘은 사용자로부터 명령을 받아 명령에 해당하는 프로그램을 실행한다.
-  그림처럼 명령 해석기는 다른 프로그램이 실행되는 동안에도 자신의 실행이 계속할수있다.
-  쉘 프로세스와 명령 프로세스는 동시에 존재한다.
-  쉘은 fork() 라는 시스템 콜을 수행해서 새로운 프로세스를 생성하며 새로 생성된 프로세스는 exec()이 실행되며 새 프로세스상에서 새로운 프로그램이 실행 될 수 있도록 한다.
-  한편 쉘 명령 방식에 따라 새 프로세스 종료를 기다리거나 기다리지않고 자신을 이어나갈 수 있다.
   -  사용자는 쉘을 통해 다른 프로그램을 실행하도록 요청하거나 기존 프로그램 진행상황 감시하고 그 프로구램의 우선순위를 병행하는등 요청을 자유롭게 할 수있다.
   -  프로세스가 끝나면 종료하기 위해 엑시트 시스템 콜 실행, 적절한 상태코드가 명령해석기로 전달된다. 이런 상태, 오류코드는 쉘이나 다른프로그램들이 이후에 이용할 수 있다.

<br>

<br>

## Types of System Calls

-  File Management (파일 다루는 시스템 콜)
-  커널은 파일 생성 삭제 시스템 콜 제공
-  파일을 오픈하고 읽고 쓰고 접근위치 바꾸는 시스템콜 도 있음, 클로즈 시스템을 마감도한다.
-  파일 속성, 변경 시스템콜도 존재.
-  디렉토리(폴더) 에 관련된 시스템콜도 존재한다. API, 시스템 프로그램 제공하기도한다.

시스템 프로그램에 다른 프로그램에 의해 호출가능하다면 다른 프로그램의 입장에서 이 시스템 프로그램이 API 가 된다.

-  infromation maintenance
   -  프로세스는 추가 자원이 (메인메모리 디스크드라이브, 파일)등 필요 할 수도 있다.
   -  해당 자원이 가용하다면 이 자원이 프로세스에게 주어지고 프로세스는 실행을 이어나간다.
   -  가용못한다면 프로세스는 자원을 기다려야한다. 사용 대기, 사용 반납 또한 시스템 콜이다.
   -  장치 장착 해체 등등 시스템콜이다.
-  통신
   -  프로세스 간통신, connection 만드는 것
   -  송신, 수신

<br>

<br>

## Types of System Calls (Cont.)

-  protection
   -  접근 허가.
   -  모든 컴퓨터 시스템에서 보호 문제를 고려해야한다.
   -  권한 생성, 권한얻는 시스템콜, 특정 사용자 접근권한설정 등등

<br>

<br>

## 윈도우, unix의 실제 시스템 콜의 예

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/26b916bc-b6c6-432e-98ae-b1505b256293/Untitled.png)

6개의 시스템 콜

유닉스 기준

<br>

<br>

## 2.5 System programs

운영체제에 포함되어있는 각종 유틸리티 프로그램

커널이 아니다.

-  시스템 프로그램은 사용자 관리자 개발자에게 편리한 환경을 제공하는 소프트웨어이다.
-  디폴트 설치도 있고 운영체제와는 별도로 스포트웨어 패키지로 설치해야하는 것도 있따.
-  파일 관리 시스템 프로그램(윈도우의 탐색기 프로그램과 동일.)
-  파일 디렉토리에 권한 모든 조작.

상태 정보 시스템 프로그램. 성능 정보, 로깅 등등 도 있다.

파일 모디피케이션

-  텍스트 에디터(파일 생성 수정)
   -  파일 내용 검색하거나 텍스트 형식 변경 등등
   -  유닉스 운영체제가 아주 잘 갖춰놓고 있다.
-  프로그래밍 랭귀지 서퍼트
   -  컴파일러, 어셈블러, 비거버 등과 함께 스크립트 언어를 위한 프로그램.
-  프로그램 로드, 실행
-  통산 접속 을 위한 수단.
   -  한사용자가 다른 사용자 화면에 텍스트 메세지, 웹 브라우징, 이메일, 원격접속, 파일 전송 등 대부분 클라이언트 역할에 해당.
-  모든 시스템은 부팅 과정에서 특정 시스템 프로그램을 자동 실행하는 기능을 가지고 있다
-  정해진 기능을 수행 후 종료, 일부 프로그램은 숏다운까지 계속 실행 하는 경우도 있다.
-  Daemons(계속 실행 되는 시스템 프로그램)
   -  컴퓨터 부팅시 Daemons이 자동동작, 유저 프로그램이지만 항상 동작. 모니터링 같은 기능
-  시스템 프로그램과 함께 일반적인 문제를 해결하는 응용프로그램이 제공된다.
   -  워드프로세스 스프레드 시트, 게임등이 여기에 속한다. 이는 운영체제의 일부는 아니다.

```
시스템 프로그램은 사용자 공간에서 동작하는 경우도 있고, 일부 기능은 커널을 통해 처리되어야 하는 경우도 있다. 그러나 모든 시스템 프로그램이 커널로 가야 하는 것은 아니다.
```

<br>

<br>

## **2.6 Operating System Design and Implemen

tation**

[운영체제의 설계와 구현]

-  완전한 해결책은 없지만 몇가지 접근 방법은 존재한다.
-  최상위에서는 어떤 하드웨어 어떤 시스템(배치 시스템인지, 타임쉐어링인지, 싱글유저시스템인지 멀티유저시스템인지, 범용인지 리얼타임인지) 인지가 영향을 끼침.

[유저 목표와 시스템 목표]

-  유저 목표 = 사용이 쉽고 빠르고 안전하고
-  시스템 목표 = 설계,구현,유지보수가 쉬웠으면 좋겠다.

정책과 매커니즘을 구분하는 것이 중요하다. 정책이 바뀌어도 매커니즘은 안바뀌여야한다.

정책 : how 매커니즘 : what

<br>

<br>

## Implementation 구현

-  대부분의 언어는 어셈블러 → 고급언어(C, C++)
   -  고급언어의 장점은 이식이 편하다는 것이다.
   -  만약 하드웨어가 바뀐다면 코드 수정을 최소화 한다는 것이다.
      -  제일 낮은 단계를 어셈블러로
      -  메인은 C로 설계하면 된다.

개발과정에서 개발 편의성에 의해 하드웨어 상에서 직접실행하지않고 에뮬레이션 소프트웨어로 실행 하기도한다.

<br>

<br>

## **2.7 Operating System Structure**

-  MS DOS

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/a9312186-6832-48a4-8517-1ba4355d2e32/Untitled.png)

엠에스 도스..

초창기 PC에 사용되던 단순한 운영체제

커널에 해당하는 부분은 MS DOS 디바이스 드라이버와 레지던트 시스템 프로그램이다.

맨아래 ROM BIOS에 의해 입출력 등을 처리한다

-  UNIX

| 유저                | 응용프로그램들                                             |      |
| ------------------- | ---------------------------------------------------------- | ---- |
| 시스템 프로그램     | CLI(셸), 컴파일러 인터프리터, 시스템 라이브러리            |      |
| 시스템콜 인터페이스 |                                                            | 커널 |
| 커널 중간           | 파일 시스템, CPU 스케쥴링, 메모리 관리 등 운체의 모든 기능 | 커널 |
| 하드웨어 인터페이스 |                                                            | 커널 |
| HW 컨트롤러         |                                                            |      |

커널안에는 계층적 구조는 아니다. 전체로 보면 계층적이긴하다.

모놀리씩한 커널의 구조 이다. =계층적 구조는아님. 수행이 더 빠를 수있음.

하지만 많은 프로그램이 커널에 구현되어있어서 구현, 유지보수가 매우 힘들다는 단점이있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/8bfb11c4-b777-4cd2-a6d5-865374b8db90/Untitled.png)

<br>

<br>

## Layered Approach

-  시스템을 모듈화 하는 방법은 계층적 구조로 하는 경우다
   -  전체 시스템을 여러개의 레이어로 나누는 경우이다.
-  맨 안쪽 레이어0은 하드웨어 제일 바깥쪽은 사용자 인터페이스를 말한다.
   -  운영체제 커널은 이 둘 사이의 계층 0~ N - 1에 해당한다.

앞선 유닉스는 커널이 하나로 이루어져서 진정한 계층적 구조는 아니다.

-  커널의 여러개로 나뉘는 경우 각 계층은 데이터와 이를 조작하는 연산으로 구성된 추상화이다.
   -  한 계층은 자신의 자료구조, 코드 ,아래계층에 대한 함수 호출 (3가지)로 이루어진다.-> 검증과 디버깅이 쉬워진다.
   -  각 계층은 자신보다 하위계층에 제공된 연산만을 사용하여 구성. 이때 하위 계층의 연산이 어떻게 구현됐는지는 알  필요는 없고 연산이어떤걸 하는지만 알면된다.
   -  각층은 하드웨어,연산 등을 상위계층에 숨기게 되는것이다.

설계시 여러층 분배하는것이 어렵다. 각층은 자신의 하위계층만 사용할 수 있어서 매우 잘 설계해야한다. 그리고 무조건 거쳐야해서 효율성이 떨어진다.

<br>

<br>

## Microkernel System Structure

-  Microkernel
   -  커널의 크기를 줄이자!
   -  기존 Monolithic 에서 가장 중요한 3가지 기능만 남겨둔다. 나머지 기능은 user space 로 꺼낸다.
      -  Interprocess communication(통신), memory manegment(메모리), cpu scheduling(프로세스 관리)
-  전형적인 마이크로 커널의 핵심기능은 클라이언트 프로그램과 사용자수준 서비스 프로그램간의 통신 기능을 제공하는 것이다.
   -  통신의 형태는 메세지 전달 방식을 사용한다. 예를 들어 응용프로그램이 파일을 사용하고싶으면 서버 프로그램한테 메세지 전달을 하고 그 결과를 메세지 형태로 응용프로그램에 전달한다.
-  Monolithic kernel(크기가 큼) ↔ Microkernel (크기가 작음)
-  Monolithic kernel
   -  UNIX kernel망
   -  유닉스 커널이라는 한 프로그램에 모든 기능이 다 들어가 있다. 이러한 구조를 Monolithic이라 한다.
   -  코드 자체의 유지보수가 어렵다는 단점이 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/0df25d9e-e17c-4164-82ca-adf0a1f88422/Untitled.png)

-  Benefits
   -  마이크로커널 확장이 더 쉽다.
   -  운영 체제를 새로운 아키텍처로 포팅하기가 더욱 쉬워짐.
   -  더욱 안정적임(커널 모드 e에서 실행되는 코드가 적음.
   -  더욱 안전.
-  Detriments:
   -  시스템콜 횟수가 늘어난다.(모든 기능이 응용프로그램의 통신으로 이루어지기 때문이다.)
   -  Monolithics의 경우 파일 읽기는 유저가 시스템콜하면 끝인데,
   -  파일 처리 기능이 micro에서는 밖에 있기 때문에 응용프로그램이 파일을 처리하는 기능을 또다른 응용프로램인 파일 서버에게 요청을 해서 요쳥이 끝났다를 반환한다.
      -  즉 유저프로그램의 통신으로 이루어져있다.
      -  이때 micro kernel은 통신 기능을 제공한다.

<br>

<br>

## Modules

-  커널 모듈
-  커널의 핵심적인 기능 이외의 동적으로 추가 될 수 있는 서비스를 구현한 형태를 말한다.
   -  디바이스 드라이버는 탈부착 가능하게 하면 하드웨어 환경에 따라서 커스터 마이징이 가능하다.
      -  현재 있는 하드웨어만 커널에 넣자.
-  MONO의 단점을 극복한 마이크로 커널을 의미한다. 이때 module은 (loadable kernel modules)이다.
-  편리성이 많다.
-  해당 기능 수정하기위해 커널 모듈만 컴파일 하면된다. 커널을 비교적 작은 규모로 유지할 수 있다.
-  그림은 유닉스의 솔라리커널모듈을 말한다. 운체의 많은 기능이 커널 대신 커널모듈에 되어있다.
-  목적
   -  커널을 최대한 compact 하게 유지하자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/8d4cd6bf-275d-49b2-9740-c4966b21840a/Untitled.png)

<br>

<br>

## Hybrid Systems

하이브리드 시스템

하지만 대부분 오늘날 운영체제는   성능,보안,편리성을 위해 하이브리드 구조를 가진다.

-  리눅스는 모놀리씩하지만 커널모듈 지원한다.
-  윈도우도 모놀리씩하지만 마이크로 커널 일부 포함한다.

그림은 맥이다. 계층적 구조를 갖는다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/fe243759-515d-4c5a-bd43-07bd0d0a3e5b/Untitled.png)

아쿠아(user interface)

코코아(응용개발계층)

커널은 마이크로 커널(마크) 비에스디 있어서 비에스디 유닉스 시스템처럼 사용가능하다.

Mas OS는 커널 익스텐션이라는(커널모듈)도 갖고있다.

<br>

<br>

## **iOS**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/a312d764-6185-4df6-bcd9-f5084de7beba/Untitled.png)

<br>

<br>

## **Android**

-  오픈소스이며 리눅스 커널을 기본으로한다. 여기다가 메모리 디바이스관리, 파워 매니지먼트 추가
-  리눅스에다가 JVM을 집어넣었다.
-  리눅스 커널과 동일한 구조 + Dalvik(JVM)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/ccefb9e7-8b79-417d-b929-af22e009ee49/Untitled.png)

<br>

<br>

## 2.10 System Boot

-  컴퓨터 시스템에 전원들어오면 CPU는 메모리 특정 주소로부터 명령을 가져와서 시작하도록 되어있는데 대부분 특정주소는 롬 영역에 해당한다.
-  예를들어서 intel 씨피유는 전원 들어온 직후 메모리상에 fff로 번 주소명령부터 시작한다. pc의경우이곳이 ROM BIOS에 해당.

2가지 방식있다.

1. 롬 영역에 부트스트랩 로더 프로그램이 있어서  운영체제의 커널 위치를 찾아서 메모리에 로드 하고 시작시키는 방법. (부트스트랩에 하드코딩되어있어서 유연성이 좀 떨어짐)
2. 롬의 코드가 디스크등의 저장장치 앞부분에서 부트블럭을 읽어서 실행시키고 이 부트로드에서 운영체제를 로드하는 방식(일반적으로 많이 사용됨, 다른 운영체제 설치하더라도 해당 운영체제에 맞는 방식을 쉽게 만들 수 있음.)

[GRUB]이라는 부트스트랩 로더를 사용하면 여러종류 여러 커널 쉽게 선택해서 부팅할수있게한다.

<br>

<br>

## **Separating Mechanism and Policy**

1. **개요**

   -  이 예시는 메커니즘/정책 분리의 개념을 설명하는데 중점을 둡니다.
   -  카드 키 시스템을 통해 메커니즘(문을 여는 장치)과 정책(누가 어떤 문에 접근할 수 있는지)이 어떻게 분리되는지 살펴봅니다.

2. **메커니즘**

   -  카드 키 자체가 메커니즘이 됩니다.
   -  실제로 문을 여는 잠금장치와 관련된 모든 것을 포함합니다.

3. **정책**

   -  중앙 보안 서버에서 결정됩니다.
   -  누가 어떤 시간에 어떤 문을 열 수 있는지와 같은 접근 규칙과 권한을 결정합니다.

4. **분리의 이점**

   -  유연성: 접근 정책 변경 시 보안 서버의 데이터베이스를 업데이트하여 변경할 수 있습니다.
   -  효율성: 실제 문을 여는 장치를 변경하지 않고도 새로운 접근 규칙을 적용할 수 있습니다.

5. **대조적인 상황: 물리적인 키 사용**

   -  메커니즘과 정책이 뒤섞이게 됩니다.
   -  새로운 접근 규칙을 적용하기 위해 실제 잠금장치를 변경해야 합니다.

6. **결론**

   -  메커니즘/정책 분리는 유연성과 효율성을 제공하여 보안 시스템의 관리와 유지보수를 용이하게 만듭니다.
   -  카드 키 시스템은 이를 실현하는 좋은 예시입니다.

   사각형 면적을 반환해야 하는 경우.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/64c11aac-6cd1-4725-b4e3-f2f48461ad2c/Untitled.png)

추가 요구사항이 생김. (오류사항에 대한 처리)

area

-  (left가 right보다 큰경우) left → right로 처리.
-  잘못 된 정수값이 파라미터로 들어온 경우 0으로 리턴

area2

-  잘못된 파라미터가 온다면 오류 전에 -1을 리턴하도록 구성.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/e05e4997-fbe7-4d79-bc97-737820c6f360/Untitled.png)

Mechanism

-  단순 동작함 4개의 파라미터에 대해서 면적을 구한다.

Policy

-  area, area2 를 따로 구성.
-  area : 잘못된 파라미터는 0으로 결과 나오도록
-  area2 : 잘못된 파라미터가 온다면 -1로

새로운 policy를 추가할 수 있기 때문에 좋은 예시이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/87052024-dbf2-449a-978f-6752bea53f15/50fd1ef8-24b4-4122-9b81-51422838c63b/Untitled.png)