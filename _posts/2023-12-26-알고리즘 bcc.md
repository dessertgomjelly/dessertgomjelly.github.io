---
layout: single
title: "[알고리즘으로 단단해지기] 4.그래프 BCC (Biconnected graph)" 
categories: Algorithm
tag: [Graph,DFS,SCC]
use_math: true #수학 공식 가능하게
sidebar:
    nav: "counts"




---

<style>
  body {
    font-size: 16px; /* 폰트 사이즈 조절 */
  }
</style>





## BCC (Biconnected graph)

BCC는 둘 이상의 정점들이 모두 연결되어 있는 그래프이다. 

SCC는 directed graph일 때 사용하지만, BCC는 undirected graph일 때 사용할 수 있다.

### 분절점 (Articulation point)

분절점이란 무방향 그래프 (undirected graph)에서 한 정점을 삭제 했을 때 그래프가 2개 이상으로 나누어지는 정점을 의미한다.

- 2를 삭제한다면 그래프가 2개로 나뉜다.

![Untitled](/Users/dessert_gomjelly/.Trash/{{site.url}}/images/2023-12-25-알고리즘bcc/Untitled.png)

<br>

<br>

- 6을 삭제하면 그래프가 2개로 나뉜다.

![Untitled](/Users/dessert_gomjelly/.Trash/{{site.url}}/images/2023-12-25-알고리즘bcc/Untitled 1.png)

이처럼 한 정점을 삭제했을 때 그래프가 둘 이상으로 나뉜다면, 그 정점을 `분절점 (Articulation Point)` 이라 한다.

<br>

<br>

### dfn (Depth-first number)

BCC에서는 `dfn(depth-first number)` 을 통해 분절점을 구할 수 있다.

- dfn은 `dfs()`를 돌렸을 때 지나는 vertex마다 숫자를 부여하는 것이다.

Depth-First Search (DFS)를 통해 그래프를 탐색할 때, 각 vertex에 대해 **`dfn`** 값을 부여하는 것은 그 vertex가 처음으로 발견된(discovered) 시간을 나타낸다. 이 값은 그래프를 탐색하는 동안 순서대로 증가하며 할당된다.

예를 들어, 다음과 같은 그래프가 있다고 가정해봅시다:

```
   1 --- 2 --- 3
   |         |
   4 --- 5

```

DFS를 수행하면서 각 vertex에 **`dfn`** 값을 할당하는 순서를 살펴보겠습니다.

1. **시작 (예: 1):**
   - **`dfn`**: 1 (처음 발견된 시간)
2. **인접한 vertex로 이동 (예: 2):**
   - **`dfn`**: 2
3. **다시 인접한 vertex로 이동 (예: 3):**
   - **`dfn`**: 3
4. **다시 이전 vertex로 돌아와서 다른 방향으로 이동 (예: 4):**
   - **`dfn`**: 4
5. **인접한 vertex로 이동 (예: 5):**
   - **`dfn`**: 5

<br>

<br>

아래 그래프에서 $3$을 root vertex로 잡고, 시작을 $4$번 vertex로 생각하고 dfs를 하면 다음과 같다.

![Untitled](제목 없음 6789eb130cf0424384ee63cde4843e89/Untitled 2.png)

![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 3.png)

- Spanning Tree 형태로 dfn을 구하면 다음과 같다.

![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 4.png)

- 위 트리에서 확인할 수 있는 특징은 다음과 같다.
   - `root node`에서 `leaf node`로 가는 경로는 `ancestor↔descendant` (조상 ↔ 후손) 관계이다.
      - 모든 `descendant`의 `dfn`은 `ancestor`의 `dfn`보다 **크다**.
         - $1$ vertex의 `dfn`은 모든 `ancestor`의 `dfn`보다 **크다**.
         - $3$ vertex의 `dfn`은 모든 `descendant`의 `dfn`보다 **작다**.
      - 즉, $`u\text{ } is\text{ } ancestor\text{ } of\text{ } v\text{ } in\text{ } the\text{ } depth-first\text{ } spanning\text{ } tree`$일 때  $dfn(u) < dfn(v)$ 이다.

<br>

<Br>

### Back Edge

BCC에서의 `non-tree edge`는 전부 `back edge` 이다.

- Undirected graph에서의 edge 종류는 다음과 같다.

   - **Tree Edge**
   - **Backend Edge**

- 아래 그래프와 트리에서 `Back Edges` 부분은 다음과 같다.

   ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 5.png)

   ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 6.png)

- 이 Back edge를 활용하면 분절점을 쉽게 구할 수 있는데 분절점의 특성은 다음과 같다.

   - 한 vertex를 삭제했을 때 두 개의 그래프로 분할되어야 한다.

<br>

<br>

- depth-first spanning tree에서 분절점을 찾는 방법은 두 가지가 있다.

   1. 두 개 이상의 child vertex를 가진다면 분절점이다.

      - 즉, 위 tree에서 root node는 분절점이다.

         ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 7.png)

   2. low() 를 이용하여 구하는 것이다.

       

<br>

<br>

### low()

$low(u)$ 우리는 결국 vertex $u$가 도달할 수 있는 가장 작은 dfn을 구해야 한다.

- $low(u)$

   - vertex $u$가 자신이 가장 낮은 dfn수로 가기 위한 방법은 3가지 중 가장 작은 값을 구하면 된다.

      1. $dfn(u)$

         1. 자신의 dfn 수이다.

         ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 8.png)

      2. $min\{{low(w) | w\text{ }is\text{ }a\text{ }child\text{ }of\text{ }u\}}$

         1.  $u$의 child vertex인 $w$들의 $low$ 값 중 가장 작은 값이다.

      ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 9.png)

      1. $min\{{dfn(v)|(u,v)\text{ }is\text{ }a\text{ }back\text{ }edge\}}$
         1. $u$의 ancestor인 $v$로 이어지는 back edge 중 가장 작은 값이다.

   ![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 10.png)

   - 위 규칙을 수식으로 표현하면 아래와 같다.

   $$
   \hspace*{-40pt} low(u) = \min\{dfn(u) \}, \\
   \hspace*{114pt} \min\{ low(w) \,|\, w \text{ is a child of } u \}, \\
   \hspace*{136pt} \min\{ dfn(v) \,|\, (u, v) \text{ is a back edge } \} \}
   $$

<br>

<br>

$dfn$과 $low$를 구해보면 다음과 같이 구해질 것이다.

![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 11.png)

![Untitled](/Users/dessert_gomjelly/Desktop/깃허브블로그/dessertgomjelly.github.io/images/2023-12-26-알고리즘 bcc/Untitled 12.png)

<br>

<br>

